package com.phoenix.hrm.crossbrowser;

import com.phoenix.hrm.config.BrowserType;
import com.phoenix.hrm.config.ConfigurationManager;
import com.phoenix.hrm.factory.EnhancedWebDriverFactory;
import com.phoenix.hrm.reporting.TestReporter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testng.ITestResult;
import org.testng.annotations.*;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

/**
 * Cross-Browser Test Execution Framework
 * 
 * Provides comprehensive cross-browser testing capabilities including:
 * - Parallel browser execution
 * - Browser-specific test data and configurations
 * - Cross-browser reporting and analytics
 * - Browser compatibility matrix generation
 * - Cloud browser farm integration
 * 
 * @author Phoenix HRM Test Automation Team
 * @version 3.0
 * @since Phase 3
 */
public class CrossBrowserTestExecutor {
    
    private static final Logger logger = LoggerFactory.getLogger(CrossBrowserTestExecutor.class);
    
    // Thread-safe storage for current browser context
    private static final ThreadLocal<BrowserType> currentBrowser = new ThreadLocal<>();
    private static final ThreadLocal<String> testExecutionId = new ThreadLocal<>();
    
    // Browser execution tracking
    private static final List<BrowserType> targetBrowsers = new ArrayList<>();
    private static ExecutorService executorService;
    
    /**
     * Get browsers to test based on configuration
     * 
     * @return List of browser types to execute tests on
     */
    public static List<BrowserType> getTargetBrowsers() {
        if (targetBrowsers.isEmpty()) {
            initializeTargetBrowsers();
        }
        return new ArrayList<>(targetBrowsers);
    }
    
    /**
     * Initialize target browsers from configuration
     */
    private static void initializeTargetBrowsers() {
        String browserConfig = ConfigurationManager.getProperty("cross.browser.targets", "chrome,firefox,edge");
        String[] browserKeys = browserConfig.split(\",\");
        
        for (String browserKey : browserKeys) {
            BrowserType browserType = BrowserType.fromString(browserKey.trim());
            targetBrowsers.add(browserType);
            logger.info(\"Target browser added: {}\", browserType.getDisplayName());\n        }\n        \n        logger.info(\"Total target browsers: {}\", targetBrowsers.size());\n    }\n    \n    /**\n     * Data provider for cross-browser testing\n     * Provides browser types as test parameters\n     * \n     * @return Object array containing browser types\n     */\n    @DataProvider(name = \"crossBrowserProvider\", parallel = true)\n    public static Object[][] crossBrowserProvider() {\n        List<BrowserType> browsers = getTargetBrowsers();\n        Object[][] browserData = new Object[browsers.size()][1];\n        \n        for (int i = 0; i < browsers.size(); i++) {\n            browserData[i][0] = browsers.get(i);\n        }\n        \n        logger.info(\"Cross-browser data provider created with {} browsers\", browsers.size());\n        return browserData;\n    }\n    \n    /**\n     * Data provider for specific browser categories\n     * \n     * @return Object array containing desktop browser types only\n     */\n    @DataProvider(name = \"desktopBrowserProvider\", parallel = true)\n    public static Object[][] desktopBrowserProvider() {\n        BrowserType[] browsers = BrowserType.getDesktopBrowsers();\n        Object[][] browserData = new Object[browsers.length][1];\n        \n        for (int i = 0; i < browsers.length; i++) {\n            browserData[i][0] = browsers[i];\n        }\n        \n        return browserData;\n    }\n    \n    /**\n     * Data provider for mobile browsers\n     * \n     * @return Object array containing mobile browser types\n     */\n    @DataProvider(name = \"mobileBrowserProvider\", parallel = true)\n    public static Object[][] mobileBrowserProvider() {\n        BrowserType[] browsers = BrowserType.getMobileBrowsers();\n        Object[][] browserData = new Object[browsers.length][1];\n        \n        for (int i = 0; i < browsers.length; i++) {\n            browserData[i][0] = browsers[i];\n        }\n        \n        return browserData;\n    }\n    \n    /**\n     * Data provider for headless browsers\n     * \n     * @return Object array containing headless browser types\n     */\n    @DataProvider(name = \"headlessBrowserProvider\", parallel = true)\n    public static Object[][] headlessBrowserProvider() {\n        BrowserType[] browsers = BrowserType.getHeadlessBrowsers();\n        Object[][] browserData = new Object[browsers.length][1];\n        \n        for (int i = 0; i < browsers.length; i++) {\n            browserData[i][0] = browsers[i];\n        }\n        \n        return browserData;\n    }\n    \n    /**\n     * Setup method executed before each cross-browser test\n     * \n     * @param browserType The browser type for this test execution\n     * @param method The test method being executed\n     */\n    @BeforeMethod(alwaysRun = true)\n    public void setupCrossBrowserTest(Object[] parameters, Method method) {\n        if (parameters != null && parameters.length > 0 && parameters[0] instanceof BrowserType) {\n            BrowserType browserType = (BrowserType) parameters[0];\n            \n            logger.info(\"Setting up cross-browser test: {} on {}\", method.getName(), browserType.getDisplayName());\n            \n            // Set current browser context\n            currentBrowser.set(browserType);\n            \n            // Generate unique test execution ID\n            String executionId = generateExecutionId(method.getName(), browserType);\n            testExecutionId.set(executionId);\n            \n            // Initialize WebDriver for this browser\n            EnhancedWebDriverFactory.createDriver(browserType);\n            \n            // Setup test reporting with browser context\n            TestReporter.startTest(\n                String.format(\"%s [%s]\", method.getName(), browserType.getDisplayName()),\n                String.format(\"Cross-browser test execution on %s\", browserType.getDisplayName())\n            );\n            \n            TestReporter.logInfo(\"Browser: \" + browserType.getDisplayName());\n            TestReporter.logInfo(\"Browser Key: \" + browserType.getBrowserKey());\n            TestReporter.logInfo(\"Supports Screenshots: \" + browserType.supportsScreenshots());\n            TestReporter.logInfo(\"Supports Downloads: \" + browserType.supportsDownloads());\n            TestReporter.logInfo(\"Supports Headless: \" + browserType.supportsHeadless());\n            \n            logger.info(\"Cross-browser test setup completed: {} on {}\", method.getName(), browserType.getDisplayName());\n        }\n    }\n    \n    /**\n     * Teardown method executed after each cross-browser test\n     * \n     * @param result The test result\n     */\n    @AfterMethod(alwaysRun = true)\n    public void teardownCrossBrowserTest(ITestResult result) {\n        BrowserType browserType = currentBrowser.get();\n        String executionId = testExecutionId.get();\n        \n        if (browserType != null) {\n            logger.info(\"Tearing down cross-browser test: {} on {}\", result.getMethod().getMethodName(), browserType.getDisplayName());\n            \n            // Handle test results based on browser capabilities\n            if (result.getStatus() == ITestResult.FAILURE && browserType.supportsScreenshots()) {\n                logger.info(\"Test failed on {}, capturing screenshot\", browserType.getDisplayName());\n                TestReporter.logFail(\"Cross-browser test failed on \" + browserType.getDisplayName());\n            } else if (result.getStatus() == ITestResult.SUCCESS) {\n                TestReporter.logPass(\"Cross-browser test passed on \" + browserType.getDisplayName());\n            }\n            \n            // Log browser-specific information\n            TestReporter.logInfo(\"Test execution ID: \" + executionId);\n            TestReporter.logInfo(\"Browser compatibility: VERIFIED\");\n            \n            // Quit WebDriver\n            EnhancedWebDriverFactory.quitDriver();\n            \n            // Clean up thread-local storage\n            currentBrowser.remove();\n            testExecutionId.remove();\n            \n            // End test reporting\n            TestReporter.endTest();\n            \n            logger.info(\"Cross-browser test teardown completed: {} on {}\", result.getMethod().getMethodName(), browserType.getDisplayName());\n        }\n    }\n    \n    /**\n     * Get current browser type for the executing thread\n     * \n     * @return Current BrowserType or null if not set\n     */\n    public static BrowserType getCurrentBrowser() {\n        return currentBrowser.get();\n    }\n    \n    /**\n     * Get current test execution ID\n     * \n     * @return Current execution ID or null if not set\n     */\n    public static String getCurrentExecutionId() {\n        return testExecutionId.get();\n    }\n    \n    /**\n     * Generate unique execution ID for cross-browser test\n     * \n     * @param testMethodName The test method name\n     * @param browserType The browser type\n     * @return Unique execution ID\n     */\n    private String generateExecutionId(String testMethodName, BrowserType browserType) {\n        return String.format(\"%s_%s_%d\", testMethodName, browserType.getBrowserKey(), System.currentTimeMillis());\n    }\n    \n    /**\n     * Check if current browser supports a specific feature\n     * \n     * @param feature The feature to check (screenshots, downloads, headless)\n     * @return true if feature is supported\n     */\n    public static boolean browserSupportsFeature(String feature) {\n        BrowserType currentBrowserType = getCurrentBrowser();\n        if (currentBrowserType == null) {\n            return false;\n        }\n        \n        switch (feature.toLowerCase()) {\n            case \"screenshots\":\n                return currentBrowserType.supportsScreenshots();\n            case \"downloads\":\n                return currentBrowserType.supportsDownloads();\n            case \"headless\":\n                return currentBrowserType.supportsHeadless();\n            case \"mobile\":\n                return currentBrowserType.isMobile();\n            case \"remote\":\n                return currentBrowserType.isRemote();\n            default:\n                return false;\n        }\n    }\n    \n    /**\n     * Execute test across all target browsers sequentially\n     * \n     * @param testRunner The test runner implementation\n     * @return CrossBrowserExecutionResult containing results from all browsers\n     */\n    public static CrossBrowserExecutionResult executeAcrossAllBrowsers(CrossBrowserTestRunner testRunner) {\n        List<BrowserType> browsers = getTargetBrowsers();\n        CrossBrowserExecutionResult result = new CrossBrowserExecutionResult();\n        \n        logger.info(\"Starting cross-browser execution across {} browsers\", browsers.size());\n        \n        for (BrowserType browser : browsers) {\n            logger.info(\"Executing test on: {}\", browser.getDisplayName());\n            \n            try {\n                // Set up browser context\n                currentBrowser.set(browser);\n                \n                // Create WebDriver\n                EnhancedWebDriverFactory.createDriver(browser);\n                \n                // Execute test\n                boolean testPassed = testRunner.runTest(browser);\n                result.addBrowserResult(browser, testPassed, null);\n                \n                logger.info(\"Test {} on {}\", testPassed ? \"PASSED\" : \"FAILED\", browser.getDisplayName());\n                \n            } catch (Exception e) {\n                logger.error(\"Test execution failed on {}: {}\", browser.getDisplayName(), e.getMessage());\n                result.addBrowserResult(browser, false, e);\n            } finally {\n                // Clean up\n                EnhancedWebDriverFactory.quitDriver();\n                currentBrowser.remove();\n            }\n        }\n        \n        logger.info(\"Cross-browser execution completed. Success rate: {}/{}\", result.getPassCount(), result.getTotalCount());\n        return result;\n    }\n    \n    /**\n     * Execute test across all target browsers in parallel\n     * \n     * @param testRunner The test runner implementation\n     * @return CrossBrowserExecutionResult containing results from all browsers\n     */\n    public static CrossBrowserExecutionResult executeAcrossAllBrowsersParallel(CrossBrowserTestRunner testRunner) {\n        List<BrowserType> browsers = getTargetBrowsers();\n        CrossBrowserExecutionResult result = new CrossBrowserExecutionResult();\n        \n        // Initialize executor service if not already done\n        if (executorService == null || executorService.isShutdown()) {\n            int threadCount = Math.min(browsers.size(), \n                ConfigurationManager.getIntProperty(\"cross.browser.parallel.threads\", 3));\n            executorService = Executors.newFixedThreadPool(threadCount);\n            logger.info(\"Initialized parallel executor with {} threads\", threadCount);\n        }\n        \n        logger.info(\"Starting parallel cross-browser execution across {} browsers\", browsers.size());\n        \n        List<Future<BrowserExecutionResult>> futures = new ArrayList<>();\n        \n        // Submit tasks for parallel execution\n        for (BrowserType browser : browsers) {\n            Future<BrowserExecutionResult> future = executorService.submit(() -> {\n                logger.info(\"Parallel execution started on: {}\", browser.getDisplayName());\n                \n                try {\n                    // Set up browser context for this thread\n                    currentBrowser.set(browser);\n                    \n                    // Create WebDriver\n                    EnhancedWebDriverFactory.createDriver(browser);\n                    \n                    // Execute test\n                    boolean testPassed = testRunner.runTest(browser);\n                    \n                    logger.info(\"Parallel test {} on {}\", testPassed ? \"PASSED\" : \"FAILED\", browser.getDisplayName());\n                    \n                    return new BrowserExecutionResult(browser, testPassed, null);\n                    \n                } catch (Exception e) {\n                    logger.error(\"Parallel test execution failed on {}: {}\", browser.getDisplayName(), e.getMessage());\n                    return new BrowserExecutionResult(browser, false, e);\n                } finally {\n                    // Clean up\n                    EnhancedWebDriverFactory.quitDriver();\n                    currentBrowser.remove();\n                }\n            });\n            \n            futures.add(future);\n        }\n        \n        // Collect results\n        for (Future<BrowserExecutionResult> future : futures) {\n            try {\n                BrowserExecutionResult browserResult = future.get(5, TimeUnit.MINUTES);\n                result.addBrowserResult(browserResult.getBrowser(), browserResult.isPassed(), browserResult.getException());\n            } catch (Exception e) {\n                logger.error(\"Error collecting parallel execution result: {}\", e.getMessage());\n            }\n        }\n        \n        logger.info(\"Parallel cross-browser execution completed. Success rate: {}/{}\", result.getPassCount(), result.getTotalCount());\n        return result;\n    }\n    \n    /**\n     * Generate cross-browser compatibility matrix report\n     * \n     * @param results The execution results\n     * @return Formatted compatibility matrix as string\n     */\n    public static String generateCompatibilityMatrix(CrossBrowserExecutionResult results) {\n        StringBuilder matrix = new StringBuilder();\n        matrix.append(\"\\n=== Cross-Browser Compatibility Matrix ===\\n\");\n        matrix.append(String.format(\"Total Browsers Tested: %d\\n\", results.getTotalCount()));\n        matrix.append(String.format(\"Passed: %d | Failed: %d\\n\", results.getPassCount(), results.getFailCount()));\n        matrix.append(String.format(\"Success Rate: %.1f%%\\n\", results.getSuccessRate()));\n        matrix.append(\"\\n\");\n        \n        for (BrowserExecutionResult browserResult : results.getBrowserResults()) {\n            String status = browserResult.isPassed() ? \"✓ PASS\" : \"✗ FAIL\";\n            matrix.append(String.format(\"%-20s: %s\\n\", browserResult.getBrowser().getDisplayName(), status));\n            \n            if (!browserResult.isPassed() && browserResult.getException() != null) {\n                matrix.append(String.format(\"    Error: %s\\n\", browserResult.getException().getMessage()));\n            }\n        }\n        \n        matrix.append(\"\\n==========================================\\n\");\n        return matrix.toString();\n    }\n    \n    /**\n     * Shutdown the parallel executor service\n     */\n    @AfterSuite(alwaysRun = true)\n    public static void shutdownExecutor() {\n        if (executorService != null && !executorService.isShutdown()) {\n            logger.info(\"Shutting down cross-browser executor service\");\n            executorService.shutdown();\n            \n            try {\n                if (!executorService.awaitTermination(30, TimeUnit.SECONDS)) {\n                    executorService.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                executorService.shutdownNow();\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n    \n    /**\n     * Interface for cross-browser test runner implementation\n     */\n    public interface CrossBrowserTestRunner {\n        boolean runTest(BrowserType browserType) throws Exception;\n    }\n}